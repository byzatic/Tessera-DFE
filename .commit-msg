perf(storage): optimize StorageManager and Storage for concurrent performance

## Problem
StorageManager and Storage had several performance bottlenecks:
1. Double map lookups (containsKey + get/put) - 2 hash operations per access
2. Non-atomic check-then-act patterns causing race conditions
3. putItemToStorage using delete+create instead of atomic upsert
4. Apache Commons Math Pair creating unnecessary allocations in list()
5. Bug: searchGlobalStorage checking containsKey twice

## Changes

### Storage.java
- Use putIfAbsent instead of containsKey+put (atomic, 1 hash op)
- Use replace instead of containsKey+put for updates
- read() now throws if item not found (was returning null with @NotNull)
- list() uses Map.Entry instead of Apache Commons Pair
- Fields made final for JIT optimization

### StorageManager.java  
- searchNodeStorage: Use computeIfAbsent for atomic lazy initialization
- searchGlobalStorage: Fixed double containsKey check, added proper validation
- putItemToStorage: Use update+create fallback instead of delete+create
- getItemFromStorage: Single read instead of contains+read
- Removed redundant isNodeStorageExists/initializeNodeStorage methods

### Interfaces
- StorageInterface: list() returns List<Map.Entry<>> instead of List<Pair<>>
- GlobalStorageManagerInterface: Same change
- NodeStorageManagerInterface: Same change

### StorageApi (both)
- Updated to use Map.Entry.getKey()/getValue() instead of Pair.getFirst()/getSecond()

## Impact
- Reduced hash operations per access from 2 to 1
- Eliminated race conditions in storage initialization
- Fewer allocations (no Pair objects)
- Thread-safe lazy initialization

Refs #18
